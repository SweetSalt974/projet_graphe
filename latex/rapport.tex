\documentclass{report}

\usepackage[ruled,vlined]{algorithm2e}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}
\usepackage{graphicx}
\usepackage[margin=1.25in]{geometry}
\usepackage{fancyhdr}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}

%beginning of report
\begin{document}
\begin{titlepage}
\fancypagestyle{}{}
\begin{figure}[t]
    \centerline{\includegraphics[scale=0.4]{Logo.png}}
    \centering
	\vspace{1cm}
    {\huge\bfseries RAMASSAGE DE DECHETS \\}
    {\huge\bfseries Projet algorithmique des graphes \\}
	\vspace{2cm}
	{\Large\itshape Benjamin DAYRES \\ Mohamed Taha SANDI \\ Samuel LANDEAU \\ Thomas COUTAYE \\}
	\vspace{1cm}
	{\large DFD\par}
    {\large DFD\par}

\end{figure}
\end{titlepage}

\newpage

\renewcommand{\contentsname}{Table des matières}
\tableofcontents

\newpage

\section{\Large Introduction }
\subsection{\Large Présentation du projet}
\hspace{0,5cm} \Large Le projet \`a  r\'ealiser consiste \`a concevoir et programmer des algorithmes de ramassage pour un robot charg\'e de collecter K d\'echets r\'epartis al\'etoirement
sur une grille carr\'ee de c\^ot\'e N. Le robot en question poss\`ede une vitesse de d\'eplacement constante unitaire et peut changer de direction en tournant sur lui m\^eme, avec un temps de changement
de direction d\'ependant de l'angle de rotation. Apr\`es avoir ramass\'e tous les d\'echets, le robot devra retourner \`a sa position initiale.
Le monde pourra \'eventuellement contenir des obstacles ayant une forme rectangulaire. Dans ce cas l\`a, le robot n'aura pas la possibilit\'    e de les traverser et devra chercher un chemin alternatif
sans obstacles pour atteindre sa destination.

\subsection{\Large Objectif du projet}
\hspace{0,5cm} \Large Le but du projet est de r\'epondre aux trois questions suivantes : \\
\hspace{1 cm} 
\begin{itemize}
\item Comment pourra-t-on mod\'eliser algorithmiquement les deux mondes o\`u \'evoluera notre robot ?
\item Quel algorithme nous permettra de resoudre de mani\`ere optimale notre probl\`eme ?
\item Une fois que nous avons mod\'elis\'e les deux mondes, comment pouvons-nous rendre l'utilisation de nos impl\'ementations facile et accessible à d'autres personnes ?
\end{itemize}

\newpage
\section{\Large Mod\'elisation des deux mondes}
\hspace{0,5 cm} \Large Pour mod\'eliser le monde sans obstacles, on utilisera un graphe complet dont le nombre de vertices est \'egal aux nombre de d\'echets pr\'esents sur la grille plus notre 
position initiale. Ajoutons \`a cela que chaque ar\^ete de notre graphe portera un poids qui n'est autre que la distance euclidienne entre ses deux extremit\'es.
\begin{figure}[!h]
    \centerline{\includegraphics[scale=1]{best_path_arbitrary-1.png}}
    \caption{Exemple de graphe repr\'esentant un monde sans obstacle} 
  \end{figure}

Pour faire la différence entre le monde avec et sans obstacle, dans le monde avec obstacle on récupère la liste des obstacles et pour chaque chemin possible dans le graphe, nous verifions si ils passent par un obstacle, alors nous changer le poids du chemin en une grande valeur pour si c'est le cas. Tout ceci fait que les algorithmes pour trouver le chemin optimal sera le même pour les deux.


\section{Nos algorithmes solutions}

Afin de résoudre ce problème de manière optimal nous nous sommes posé la question suivante : Comment trouver le chemin de rammassage optimal ?

Une solution évidente est de calculer tous les chemins possibles et de choisir le plus cour. Si les n dechets sont représenté par une suites sans répétition de nombre entre 1 et n - 1 et la position de départ par le sommet 0, on peut conclure qu'il faut calculer la longueur du chemin parcourus pour toute permutation de l'ensemble [1 ; n].

Ainsi nous définissons les fonctions auxiliaire suivantes : \\

\begin{algorithm}[H]
  \SetAlgoLined
  \KwResult{Un tableau contenant toutes les permutations de [1 ; n]}
  \caption{allPermutations(n)}
\end{algorithm}

\begin{algorithm}[H]
    \SetAlgoLined
    \KwResult{Le temps que le robot prendra pour parcourir la permutation}
    time = 0\;
    currentVector = [0;1]\;
    \For{i from 0 to longueur(permutation) - 1}{
        time = time + poid(i, i+1)\;
        newVector = [pos[i][0] - pos[i+1][0] ; pos[i][1] - pos[i+1][1]]\;
        time = C * angle(currentVector, newVector)\;
        currentVector = newVector\;
    }
    return time\;
    \caption{permLength()}
  \end{algorithm}

  \begin{algorithm}[H]
    \SetAlgoLined
    \KwResult{Le meilleur chemin pour rammasser les déchets}
    permutations = allPermutations(n)\;
    bestPath = []\;
    minLength = $\infty$ \;
    \For{i from 0 to longueur(permutations)}
    {
        \If{permLength(permutations[i]) $<$ minLength}
        {
            minLength = permLength(permutations[i])\;
            bestPath = permutations[i]\;
        }
    }
    return bestPath\;
    \caption{bruteForce()}
  \end{algorithm}

  Cependant, on constate rapidement que cette approche à ses limites. En effet, le nombre de permutation pour un ensemble de taille $n$ est $!n$. La complexité en temps et en mémoire de notre alogrithme est donc de $O(n)$.

  Bien qu'il soit possible de réduire la complexité en espace en fonction de comment l'implémentation est fait dans un language données, en utilisant par exemple, un itérateur en Python, la complexité en temps elle reste inchangé.

  Afin de trouver un autre algorithme, nous nous sommes demandé s'il n'existait pas déjà un problème documenté auquel nous pourrions ramener le notre.

  Et, en effet, il est possible de ramener ce problème du rammassage de dechets au problème connu du marchand de commerce.

  Il existe de nombreux algorithms permettant de résoudre celui-ci, et nous nous sommes interressé à l'algorithme de Christofides.
  
  L'algorithme de Christofides donne une approximation de la solution du marchand de commerce.

  Nous avons donc décidé d'utiliser une variante de celui-ci. En effet, l'algorithme de Christofides consiste à chercher l'arbre couvrant de poid minimum d'un graphe, puis d'effectuer un traitement sur celui-ci.


  Cependant, nous allons simplement effectuer un parcours en profondeur de celui-ci, et ajouter les sommets dans l'ordre de ce parcours à notre tourné.

%% Donner l'algo. Normalement il n'est pas nécessaire de décrire les algos de calcul de l'arbre couvrant minimal (Prim ou Kruskal) et de parcours en profondeur, car ils sont détaillé dans le cours.

  Cependant, la solution obtenue n'est pas très satisfaisante et il est possible de très simplment améliorer ce résultat. \\ 

  En effet il existe une optimisation possible pour le problème du marchand de commerce, l'algorithme 2-optimisation.

  Cette algorithme consiste à chercher avec une heuristic une solution initial de chemin et puis pour tout couple de chemin dans cette solution qui se croise de vérifier le poid du chemin. Si en décroissant les chemins ont obtient un meilleur chemin on continue.

  Cette algorithme se comporte en $\theta n^2$ sur la plupart des graphes et donc est plus rapide que l'algorithme brute, par contre il n'assure pas absolument la bonne réponse mais une bonne approximationpour les graphes d'une taille trop importante. 
%% Basez vous sur le code en python + articles Wikipédia (2-optmisation problème marchand de commerce)

  En effet, dans le parcours obtenue, certaines arrêtes peuvent être croisé, ce qui n'est pas optimal. Ainsi, en décroisant celles-ci, on obtient un bien meilleur résultat.

\end{document}
